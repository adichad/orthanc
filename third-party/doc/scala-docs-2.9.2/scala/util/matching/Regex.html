<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scala.util.matching.Regex</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="type">
      <div id="definition">
        <a title="Go to companion" href="Regex$.html"><img src="../../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="scala" class="extype" href="../../package.html">scala</a>.<a name="scala.util" class="extype" href="../package.html">util</a>.<a name="scala.util.matching" class="extype" href="package.html">matching</a></p>
        <h1><a title="Go to companion" href="Regex$.html">Regex</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Regex</span><span class="result"> extends <a name="scala.Serializable" class="extype" href="../../Serializable.html">Serializable</a></span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>This class provides methods for creating and using regular expressions.
 It is based on the regular expressions of the JDK since 1.4.</p><p> Its main goal is to extract strings that match a pattern, or the subgroups
 that make it up. For that reason, it is usually used with for comprehensions
 and matching (see methods for examples).</p><p> A Regex is created from a java.lang.String representation of the
 regular expression pattern<sup>1</sup>. That pattern is compiled
 during construction, so frequently used patterns should be declared outside
 loops if performance is of concern. Possibly, they might be declared on a
 companion object, so that they need only to be initialized once.</p><p> The canonical way of creating regex patterns is by using the method <code>r</code>, provided
 on java.lang.String through an implicit conversion into
 <a name="scala.collection.immutable.WrappedString" class="extype" href="../../collection/immutable/WrappedString.html">WrappedString</a>. Using triple quotes to write these
 strings avoids having to quote the backslash character (<code>\</code>).</p><p> Using the constructor directly, on the other hand, makes
 it possible to declare names for subgroups in the pattern.</p><p> For example, both declarations below generate the same regex, but the second
 one associate names with the subgroups.</p><pre>
 <span class="kw">val</span> dateP1 = <span class="lit">""</span><span class="lit">"(\d\d\d\d)-(\d\d)-(\d\d)"</span><span class="lit">""</span>.r
 <span class="kw">val</span> dateP2 = <span class="kw">new</span> scala.util.matching.Regex(<span class="lit">""</span><span class="lit">"(\d\d\d\d)-(\d\d)-(\d\d)"</span><span class="lit">""</span>, <span class="lit">"year"</span>, <span class="lit">"month"</span>, <span class="lit">"day"</span>)
</pre><p> There are two ways of using a <code>Regex</code> to find a pattern: calling methods on
 Regex, such as <code>findFirstIn</code> or <code>findAllIn</code>, or using it as an extractor in a
 pattern match.</p><p> Note, however, that when Regex is used as an extractor in a pattern match, it
 only succeeds if the whole text can be matched. For this reason, one usually
 calls a method to find the matching substrings, and then use it as an extractor
 to break match into subgroups.</p><p> As an example, the above patterns can be used like this:</p><pre>
 <span class="kw">val</span> dateP1(year, month, day) = <span class="lit">"2011-07-15"</span>

 <span class="cmt">// val dateP1(year, month, day) = "Date 2011-07-15" // throws an exception at runtime</span>

 <span class="kw">val</span> copyright: <span class="std">String</span> = dateP1 findFirstIn <span class="lit">"Date of this document: 2011-07-15"</span> <span class="kw">match</span> {
   <span class="kw">case</span> <span class="std">Some</span>(dateP1(year, month, day)) <span class="kw">=&gt;</span> <span class="lit">"Copyright "</span>+year
   <span class="kw">case</span> <span class="std">None</span>                           <span class="kw">=&gt;</span> <span class="lit">"No copyright"</span>
 }

 <span class="kw">val</span> copyright: <span class="std">Option</span>[<span class="std">String</span>] = <span class="kw">for</span> {
   dateP1(year, month, day) <span class="kw">&lt;-</span> dateP1 findFirstIn <span class="lit">"Last modified 2011-07-15"</span>
 } <span class="kw">yield</span> year

 <span class="kw">def</span> getYears(text: <span class="std">String</span>): Iterator[<span class="std">String</span>] = <span class="kw">for</span> (dateP1(year, _, _) <span class="kw">&lt;-</span> dateP1 findAllIn text) <span class="kw">yield</span> year
 <span class="kw">def</span> getFirstDay(text: <span class="std">String</span>): <span class="std">Option</span>[<span class="std">String</span>] = <span class="kw">for</span> (m <span class="kw">&lt;-</span> dateP2 findFirstMatchIn text) <span class="kw">yield</span> m group <span class="lit">"day"</span>
</pre><p> Regex does not provide a method that returns a <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a>. One can
 use java.lang.String <code>matches</code> method, or, if <code>Regex</code> is preferred,
 either ignore the return value or test the <code>Option</code> for emptyness. For example:</p><pre>
 <span class="kw">def</span> hasDate(text: <span class="std">String</span>): <span class="std">Boolean</span> = (dateP1 findFirstIn text).nonEmpty
 <span class="kw">def</span> printLinesWithDates(lines: Traversable[<span class="std">String</span>]) {
   lines foreach { line <span class="kw">=&gt;</span>
     dateP1 findFirstIn line foreach { _ <span class="kw">=&gt;</span> println(line) }
   }
 }
</pre><p> There are also methods that can be used to replace the patterns
 on a text. The substitutions can be simple replacements, or more
 complex functions. For example:</p><pre>
 <span class="kw">val</span> months = <span class="std">Map</span>( <span class="num">1</span> -&gt; <span class="lit">"Jan"</span>, <span class="num">2</span> -&gt; <span class="lit">"Feb"</span>, <span class="num">3</span> -&gt; <span class="lit">"Mar"</span>,
                   <span class="num">4</span> -&gt; <span class="lit">"Apr"</span>, <span class="num">5</span> -&gt; <span class="lit">"May"</span>, <span class="num">6</span> -&gt; <span class="lit">"Jun"</span>,
                   <span class="num">7</span> -&gt; <span class="lit">"Jul"</span>, <span class="num">8</span> -&gt; <span class="lit">"Aug"</span>, <span class="num">9</span> -&gt; <span class="lit">"Sep"</span>,
                   <span class="num">10</span> -&gt; <span class="lit">"Oct"</span>, <span class="num">11</span> -&gt; <span class="lit">"Nov"</span>, <span class="num">12</span> -&gt; <span class="lit">"Dec"</span>)

 <span class="kw">import</span> scala.util.matching.Regex.Match
 <span class="kw">def</span> reformatDate(text: <span class="std">String</span>) = dateP2 replaceAllIn ( text, (m: Match) <span class="kw">=&gt;</span>
   <span class="lit">"%s %s, %s"</span> format (months(m group <span class="lit">"month"</span> toInt), m group <span class="lit">"day"</span>, m group <span class="lit">"year"</span>)
 )
</pre><p> You can use special pattern syntax constructs like <code>(?idmsux-idmsux)</code>¹ to switch
 various regex compilation options like <code>CASE_INSENSITIVE</code> or <code>UNICODE_CASE</code>.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.SerialVersionUID" class="extype" href="../../SerialVersionUID.html">SerialVersionUID</a></span><span class="args">(<span>
      uid = 
      <span class="symbol">2094783597747625537L</span>
    </span>)</span>
              
        </dd><dt>Source</dt><dd><a target="_blank" href="https://github.com/scala/scala/tree/v2.9.2/src/library/scala/util/matching/Regex.scala#L1">Regex.scala</a></dd><dt>Version</dt><dd><p>1.1, 29/01/2008
</p></dd><dt>Note</dt><dd><span class="cmt"><p>¹ A detailed description is available in java.util.regex.Pattern.</p></span></dd><dt>See also</dt><dd><span class="cmt"><p>java.util.regex.Pattern
</p></span></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a name="scala.Serializable" class="extype" href="../../Serializable.html">Serializable</a>, <span name="java.io.Serializable" class="extype">Serializable</span>, AnyRef, <a name="scala.Any" class="extype" href="../../Any.html">Any</a></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="scala.util.matching.Regex" class="in"><span>Regex</span></li><li name="scala.Serializable" class="in"><span>Serializable</span></li><li name="java.io.Serializable" class="in"><span>Serializable</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="scala.util.matching.Regex#this" data-isabs="false">
      <a id="this:Regex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Regex</span><span class="params">(<span name="regex">regex: String</span>, <span name="groupNames">groupNames: String*</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">regex</dt><dd class="cmt"><p>A string representing a regular expression</p></dd><dt class="param">groupNames</dt><dd class="cmt"><p>A mapping from names to indices in capture groups</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <a name="scala.Any" class="extype" href="../../Any.html">Any</a></span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Test two objects for inequality.</p><div class="fullcomment"><div class="comment cmt"><p>Test two objects for inequality.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if !(this == that), false otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <a name="scala.Int" class="extype" href="../../Int.html">Int</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Equivalent to <code>x.hashCode</code> except for boxed numeric types.</p><div class="fullcomment"><div class="comment cmt"><p>Equivalent to <code>x.hashCode</code> except for boxed numeric types.
 For numerics, it returns a hash value which is consistent
 with value equality: if two value type instances compare
 as true, then ## will produce the same hash value for each
 of them.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a hash value consistent with ==
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → <a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <a name="scala.Any" class="extype" href="../../Any.html">Any</a></span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Test two objects for equality.</p><div class="fullcomment"><div class="comment cmt"><p>Test two objects for equality.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Cast the receiver object to be of type <code>T0</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Cast the receiver object to be of type <code>T0</code>.</p><p> Note that the success of a cast at runtime is modulo Scala's erasure semantics.
 Therefore the expression <code>1.asInstanceOf[String]</code> will throw a <code>ClassCastException</code> at
 runtime, while the expression <code>List(1).asInstanceOf[List[String]]</code> will not.
 In the latter example, because the type argument is erased as part of compilation it is
 not possible to check whether the contents of the list are of the requested type.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the receiver object.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd><dt>Exceptions thrown</dt><dd><span class="cmt">ClassCastException<p>if the receiver object is not an instance of the erasure of type <code>T0</code>.</p></span></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a copy of the receiver object.</p><div class="fullcomment"><div class="comment cmt"><p>Create a copy of the receiver object.</p><p> The default implementation of the <code>clone</code> method is platform dependent.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a copy of the receiver object.
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.throws" class="extype" href="../../throws.html">throws</a></span><span class="args">()</span>
              
        </dd><dt>Note</dt><dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tests whether the argument (<code>arg0</code>) is a reference to the receiver object (<code>this</code>).</p><div class="fullcomment"><div class="comment cmt"><p>Tests whether the argument (<code>arg0</code>) is a reference to the receiver object (<code>this</code>).</p><p> The <code>eq</code> method implements an <a href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a> on
 non-null instances of <code>AnyRef</code>, and has three additional properties:</p><ul><li>It is consistent: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, multiple invocations of
    <code>x.eq(y)</code> consistently returns <code>true</code> or consistently returns <code>false</code>.</li><li>For any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(null)</code> and <code>null.eq(x)</code> returns <code>false</code>.</li><li><code>null.eq(null)</code> returns <code>true</code>.</li></ul><p> When overriding the <code>equals</code> or <code>hashCode</code> methods, it is important to ensure that their behavior is
 consistent with reference equality.  Therefore, if two objects are references to each other (<code>o1 eq o2</code>), they
 should be equal to each other (<code>o1 == o2</code>) and they should hash to the same value (<code>o1.hashCode == o2.hashCode</code>).
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the argument is a reference to the receiver object; <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <a name="scala.Any" class="extype" href="../../Any.html">Any</a></span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The equality method for reference types.</p><div class="fullcomment"><div class="comment cmt"><p>The equality method for reference types.  See equals in <a name="scala.Any" class="extype" href="../../Any.html">Any</a>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → <a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Called by the garbage collector on the receiver object when there
 are no more references to the object.</p><div class="fullcomment"><div class="comment cmt"><p>Called by the garbage collector on the receiver object when there
 are no more references to the object.</p><p> The details of when and if the <code>finalize</code> method is invoked, as
 well as the interaction between <code>finalize</code> and non-local returns
 and exceptions, are all platform dependent.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.throws" class="extype" href="../../throws.html">throws</a></span><span class="args">()</span>
              
        </dd><dt>Note</dt><dd><span class="cmt"><p>not specified by SLS as a member of AnyRef
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#findAllIn" data-isabs="false">
      <a id="findAllIn(CharSequence):MatchIterator"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findAllIn</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.util.matching.Regex.MatchIterator" class="extype" href="Regex$$MatchIterator.html">MatchIterator</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return all matches of this regexp in given character sequence as a scala.util.mathcing.Regex.MatchIterator,
 which is a special <a name="scala.collection.Iterator" class="extype" href="../../collection/Iterator.html">Iterator</a> that returns the
 matched strings, but can also be converted into a normal iterator
 that returns objects of type <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>
 that can be queried for data such as the text that precedes the
 match, subgroups, etc.</p><div class="fullcomment"><div class="comment cmt"><p>Return all matches of this regexp in given character sequence as a scala.util.mathcing.Regex.MatchIterator,
 which is a special <a name="scala.collection.Iterator" class="extype" href="../../collection/Iterator.html">Iterator</a> that returns the
 matched strings, but can also be converted into a normal iterator
 that returns objects of type <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>
 that can be queried for data such as the text that precedes the
 match, subgroups, etc.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The text to match against.</p></dd><dt>returns</dt><dd class="cmt"><p>A scala.util.matching.Reegex.MatchIterator of all matches.</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
<span class="kw">for</span> (words <span class="kw">&lt;-</span> <span class="lit">""</span><span class="lit">"\w+"</span><span class="lit">""</span>.r findAllIn <span class="lit">"A simple example."</span>) <span class="kw">yield</span> words
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#findFirstIn" data-isabs="false">
      <a id="findFirstIn(CharSequence):Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findFirstIn</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return optionally first matching string of this regexp in given character sequence,
 or None if it does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Return optionally first matching string of this regexp in given character sequence,
 or None if it does not exist.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The text to match against.</p></dd><dt>returns</dt><dd class="cmt"><p>An <a name="scala.Option" class="extype" href="../../Option.html">Option</a> of the first matching string in the text.</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
<span class="lit">""</span><span class="lit">"\w+"</span><span class="lit">""</span>.r findFirstIn <span class="lit">"A simple example."</span> foreach println <span class="cmt">// prints "A"</span>
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#findFirstMatchIn" data-isabs="false">
      <a id="findFirstMatchIn(CharSequence):Option[Match]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findFirstMatchIn</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[<a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return optionally first match of this regexp in given character sequence,
 or None if it does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Return optionally first match of this regexp in given character sequence,
 or None if it does not exist.</p><p> The main difference between this method and <code>findFirstIn</code> is that the (optional) return
 type for this is <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>, through which more
 data can be obtained about the match, such as the strings that precede and follow it,
 or subgroups.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The text to match against.</p></dd><dt>returns</dt><dd class="cmt"><p>A <a name="scala.Option" class="extype" href="../../Option.html">Option</a> of <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a> of the first matching string in the text.</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
(<span class="lit">""</span><span class="lit">"[a-z]"</span><span class="lit">""</span>.r findFirstMatchIn <span class="lit">"A simple example."</span>) map (_.start) <span class="cmt">// returns Some(2), the index of the first match in the text</span>
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#findPrefixMatchOf" data-isabs="false">
      <a id="findPrefixMatchOf(CharSequence):Option[Match]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findPrefixMatchOf</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[<a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return optionally match of this regexp at the beginning of the
 given character sequence, or None if regexp matches no prefix
 of the character sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Return optionally match of this regexp at the beginning of the
 given character sequence, or None if regexp matches no prefix
 of the character sequence.</p><p> The main difference from this method to <code>findFirstMatchIn</code> is that
 this method will not return any matches that do not begin at the
 start of the text being matched against.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The text to match against.</p></dd><dt>returns</dt><dd class="cmt"><p>A <a name="scala.Option" class="extype" href="../../Option.html">Option</a> of the <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a> of the matched string.</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
<span class="lit">""</span><span class="lit">"\w+"</span><span class="lit">""</span>.r findPrefixMatchOf <span class="lit">"A simple example."</span> map (_.after) <span class="cmt">// returns Some(" simple example.")</span>
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#findPrefixOf" data-isabs="false">
      <a id="findPrefixOf(CharSequence):Option[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findPrefixOf</span><span class="params">(<span name="source">source: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return optionally match of this regexp at the beginning of the
 given character sequence, or None if regexp matches no prefix
 of the character sequence.</p><div class="fullcomment"><div class="comment cmt"><p>Return optionally match of this regexp at the beginning of the
 given character sequence, or None if regexp matches no prefix
 of the character sequence.</p><p> The main difference from this method to <code>findFirstIn</code> is that this
 method will not return any matches that do not begin at the start
 of the text being matched against.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>The text to match against.</p></dd><dt>returns</dt><dd class="cmt"><p>A <a name="scala.Option" class="extype" href="../../Option.html">Option</a> of the matched prefix.</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
<span class="lit">""</span><span class="lit">"[a-z]"</span><span class="lit">""</span>.r findPrefixOf <span class="lit">"A simple example."</span> <span class="cmt">// returns None, since the text does not begin with a lowercase letter</span>
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A representation that corresponds to the dynamic class of the receiver object.</p><div class="fullcomment"><div class="comment cmt"><p>A representation that corresponds to the dynamic class of the receiver object.</p><p> The nature of the representation is platform dependent.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a representation that corresponds to the dynamic class of the receiver object.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → <a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd><dt>Note</dt><dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <a name="scala.Int" class="extype" href="../../Int.html">Int</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The hashCode method for reference types.</p><div class="fullcomment"><div class="comment cmt"><p>The hashCode method for reference types.  See hashCode in <a name="scala.Any" class="extype" href="../../Any.html">Any</a>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the hash code value for this object.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → <a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Test whether the dynamic type of the receiver object is <code>T0</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Test whether the dynamic type of the receiver object is <code>T0</code>.</p><p> Note that the result of the test is modulo Scala's erasure semantics.
 Therefore the expression <code>1.isInstanceOf[String]</code> will return <code>false</code>, while the
 expression <code>List(1).isInstanceOf[List[String]]</code> will return <code>true</code>.
 In the latter example, because the type argument is erased as part of compilation it is
 not possible to check whether the contents of the list are of the specified type.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is an instance of erasure of type <code>T0</code>; <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <a name="scala.Boolean" class="extype" href="../../Boolean.html">Boolean</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Equivalent to <code>!(this eq that)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Equivalent to <code>!(this eq that)</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the argument is not a reference to the receiver object; <code>false</code> otherwise.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wakes up a single thread that is waiting on the receiver object's monitor.</p><div class="fullcomment"><div class="comment cmt"><p>Wakes up a single thread that is waiting on the receiver object's monitor.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Note</dt><dd><span class="cmt"><p>not specified by SLS as a member of AnyRef
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wakes up all threads that are waiting on the receiver object's monitor.</p><div class="fullcomment"><div class="comment cmt"><p>Wakes up all threads that are waiting on the receiver object's monitor.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Note</dt><dd><span class="cmt"><p>not specified by SLS as a member of AnyRef
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#pattern" data-isabs="false">
      <a id="pattern:Pattern"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">pattern</span><span class="result">: <span name="java.util.regex.Pattern" class="extype">Pattern</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The compiled pattern</p>
    </li><li visbl="pub" name="scala.util.matching.Regex#replaceAllIn" data-isabs="false">
      <a id="replaceAllIn(CharSequence,(Match) ⇒ String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replaceAllIn</span><span class="params">(<span name="target">target: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="replacer">replacer: (<a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>) ⇒ String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Replaces all matches using a replacer function.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces all matches using a replacer function. The replacer function takes a
<a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a> so that extra information can be obtained
from the match. For example:</p><pre>
<span class="kw">import</span> scala.util.matching.Regex
<span class="kw">val</span> datePattern = <span class="kw">new</span> Regex(<span class="lit">""</span><span class="lit">"(\d\d\d\d)-(\d\d)-(\d\d)"</span><span class="lit">""</span>, <span class="lit">"year"</span>, <span class="lit">"month"</span>, <span class="lit">"day"</span>)
<span class="kw">val</span> text = <span class="lit">"From 2011-07-15 to 2011-07-17"</span>
<span class="kw">val</span> repl = datePattern replaceAllIn (text, m <span class="kw">=&gt;</span> m.group(<span class="lit">"month"</span>)+<span class="lit">"/"</span>+m.group(<span class="lit">"day"</span>))
</pre><p> In the replacement String, a dollar sign (<code>$</code>) followed by a number will be
 interpreted as a reference to a group in the matched pattern, with numbers
 1 through 9 corresponding to the first nine groups, and 0 standing for the
 whole match. Any other character is an error. The backslash (<code>\</code>) character
 will be interpreted as an escape character, and can be used to escape the
 dollar sign. One can use <a name="scala.util.matching.Regex" class="extype" href="">Regex</a>'s <code>quoteReplacement</code>
 to automatically escape these characters.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>The string to match.</p></dd><dt class="param">replacer</dt><dd class="cmt"><p>The function which maps a match to another string.</p></dd><dt>returns</dt><dd class="cmt"><p>The target string after replacements.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#replaceAllIn" data-isabs="false">
      <a id="replaceAllIn(CharSequence,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replaceAllIn</span><span class="params">(<span name="target">target: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="replacement">replacement: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Replaces all matches by a string.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces all matches by a string.</p><p> In the replacement String, a dollar sign (<code>$</code>) followed by a number will be
 interpreted as a reference to a group in the matched pattern, with numbers
 1 through 9 corresponding to the first nine groups, and 0 standing for the
 whole match. Any other character is an error. The backslash (<code>\</code>) character
 will be interpreted as an escape character, and can be used to escape the
 dollar sign. One can use <a name="scala.util.matching.Regex" class="extype" href="">Regex</a>'s <code>quoteReplacement</code>
 to automatically escape these characters.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>The string to match</p></dd><dt class="param">replacement</dt><dd class="cmt"><p>The string that will replace each match</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting string</p></dd></dl><dl class="attributes block"> <div class="block">Example:
                <ol><li class="cmt"><p></p><pre>
<span class="lit">""</span><span class="lit">"\d+"</span><span class="lit">""</span>.r replaceAllIn (<span class="lit">"July 15"</span>, <span class="lit">"<NUMBER>"</span>) <span class="cmt">// returns "July <NUMBER>"</span>
</pre></li></ol>
              </div></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#replaceFirstIn" data-isabs="false">
      <a id="replaceFirstIn(CharSequence,String):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replaceFirstIn</span><span class="params">(<span name="target">target: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="replacement">replacement: String</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Replaces the first match by a string.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces the first match by a string.</p><p> In the replacement String, a dollar sign (<code>$</code>) followed by a number will be
 interpreted as a reference to a group in the matched pattern, with numbers
 1 through 9 corresponding to the first nine groups, and 0 standing for the
 whole match. Any other character is an error. The backslash (<code>\</code>) character
 will be interpreted as an escape character, and can be used to escape the
 dollar sign. One can use <a name="scala.util.matching.Regex" class="extype" href="">Regex</a>'s <code>quoteReplacement</code>
 to automatically escape these characters.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>The string to match</p></dd><dt class="param">replacement</dt><dd class="cmt"><p>The string that will replace the match</p></dd><dt>returns</dt><dd class="cmt"><p>The resulting string
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#replaceSomeIn" data-isabs="false">
      <a id="replaceSomeIn(CharSequence,(Match) ⇒ Option[String]):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">replaceSomeIn</span><span class="params">(<span name="target">target: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>, <span name="replacer">replacer: (<a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a>) ⇒ <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[String]</span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Replaces some of the matches using a replacer function that returns an <a name="scala.Option" class="extype" href="../../Option.html">Option</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Replaces some of the matches using a replacer function that returns an <a name="scala.Option" class="extype" href="../../Option.html">Option</a>.
The replacer function takes a <a name="scala.util.matching.Regex.Match" class="extype" href="Regex$$Match.html">Match</a> so that extra
information can be btained from the match. For example:</p><pre>
<span class="kw">import</span> scala.util.matching.Regex._

<span class="kw">val</span> map = <span class="std">Map</span>(<span class="lit">"x"</span> -&gt; <span class="lit">"a var"</span>, <span class="lit">"y"</span> -&gt; <span class="lit">""</span><span class="lit">"some $ and \ signs"</span><span class="lit">""</span>)
<span class="kw">val</span> text = <span class="lit">"A text with variables %x, %y and %z."</span>
<span class="kw">val</span> varPattern = <span class="lit">""</span><span class="lit">"%(\w+)"</span><span class="lit">""</span>.r
<span class="kw">val</span> mapper = (m: Match) <span class="kw">=&gt;</span> map get (m group <span class="num">1</span>) map (quoteReplacement(_))
<span class="kw">val</span> repl = varPattern replaceSomeIn (text, mapper)
</pre><p> In the replacement String, a dollar sign (<code>$</code>) followed by a number will be
 interpreted as a reference to a group in the matched pattern, with numbers
 1 through 9 corresponding to the first nine groups, and 0 standing for the
 whole match. Any other character is an error. The backslash (<code>\</code>) character
 will be interpreted as an escape character, and can be used to escape the
 dollar sign. One can use <a name="scala.util.matching.Regex" class="extype" href="">Regex</a>'s <code>quoteReplacement</code>
 to automatically escape these characters.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>The string to match.</p></dd><dt class="param">replacer</dt><dd class="cmt"><p>The function which optionally maps a match to another string.</p></dd><dt>returns</dt><dd class="cmt"><p>The target string after replacements.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#split" data-isabs="false">
      <a id="split(CharSequence):Array[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">split</span><span class="params">(<span name="toSplit">toSplit: <span name="java.lang.CharSequence" class="extype">CharSequence</span></span>)</span><span class="result">: <a name="scala.Array" class="extype" href="../../Array.html">Array</a>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Splits the provided character sequence around matches of this regexp.</p><div class="fullcomment"><div class="comment cmt"><p>Splits the provided character sequence around matches of this regexp.
</p></div><dl class="paramcmts block"><dt class="param">toSplit</dt><dd class="cmt"><p>The character sequence to split</p></dd><dt>returns</dt><dd class="cmt"><p>The array of strings computed by splitting the
                input around matches of this regexp
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The string defining the regular expression</p><div class="fullcomment"><div class="comment cmt"><p>The string defining the regular expression</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a String representation of the object.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scala.util.matching.Regex" class="extype" href="">Regex</a> → AnyRef → <a name="scala.Any" class="extype" href="../../Any.html">Any</a></dd></dl></div>
    </li><li visbl="pub" name="scala.util.matching.Regex#unapplySeq" data-isabs="false">
      <a id="unapplySeq(Any):Option[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unapplySeq</span><span class="params">(<span name="target">target: <a name="scala.Any" class="extype" href="../../Any.html">Any</a></span>)</span><span class="result">: <a name="scala.Option" class="extype" href="../../Option.html">Option</a>[List[String]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Tries to match target (whole match) and returns the matching subgroups.</p><div class="fullcomment"><div class="comment cmt"><p>Tries to match target (whole match) and returns the matching subgroups.
 if the pattern has no subgroups, then it returns an empty list on a
 successful match.</p><p> Note, however, that if some subgroup has not been matched, a <code>null</code> will
 be returned for that subgroup.</p><p> For example:</p><pre>
 <span class="kw">val</span> p1 = <span class="lit">"ab*c"</span>.r
 <span class="kw">val</span> p2 = <span class="lit">"a(b*)c"</span>.r

 <span class="kw">val</span> p1Matches = <span class="lit">"abbbc"</span> <span class="kw">match</span> {
   <span class="kw">case</span> p1() <span class="kw">=&gt;</span> <span class="kw">true</span>
   <span class="kw">case</span> _    <span class="kw">=&gt;</span> <span class="kw">false</span>
 }

 <span class="kw">val</span> numberOfB = <span class="lit">"abbbc"</span> <span class="kw">match</span> {
   <span class="kw">case</span> p2(b) <span class="kw">=&gt;</span> <span class="std">Some</span>(b.length)
   <span class="kw">case</span> _     <span class="kw">=&gt;</span> <span class="std">None</span>
 }
</pre></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>The string to match</p></dd><dt>returns</dt><dd class="cmt"><p>The matches
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.throws" class="extype" href="../../throws.html">throws</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a name="scala.Long" class="extype" href="../../Long.html">Long</a></span>, <span name="arg1">arg1: <a name="scala.Int" class="extype" href="../../Int.html">Int</a></span>)</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.throws" class="extype" href="../../throws.html">throws</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a name="scala.Long" class="extype" href="../../Long.html">Long</a></span>)</span><span class="result">: <a name="scala.Unit" class="extype" href="../../Unit.html">Unit</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@<a name="scala.throws" class="extype" href="../../throws.html">throws</a></span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="scala.Serializable" class="parent">
              <h3>Inherited from <a name="scala.Serializable" class="extype" href="../../Serializable.html">Serializable</a></h3>
            </div><div name="java.io.Serializable" class="parent">
              <h3>Inherited from <span name="java.io.Serializable" class="extype">Serializable</span></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <a name="scala.Any" class="extype" href="../../Any.html">Any</a></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">Scala programming documentation. Copyright (c) 2003-2011 <a target="_top" href="http://www.epfl.ch">EPFL</a>, with contributions from <a target="_top" href="http://typesafe.com">Typesafe</a>.</div>


    </body>
      </html>